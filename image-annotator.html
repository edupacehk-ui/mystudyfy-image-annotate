<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Image Annotator</title>
    <style>
        body { margin: 0; padding: 0; overflow: hidden; background: transparent; }
        #canvas { position: absolute; top: 0; left: 0; width: 100vw; height: 100vh; background: white; } /* White for padded areas */
        #toolbar { position: absolute; top: 10px; left: 50%; transform: translateX(-50%); background: rgba(255, 255, 255, 0.8); padding: 5px; border-radius: 5px; z-index: 10; display: flex; gap: 10px; }
        #toolbar button, #toolbar select { padding: 5px; font-size: 14px; }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div id="toolbar">
        <button id="undo">Undo</button>
        <button id="clear">Clear All</button>
        <select id="color">
            <option value="#000000">Black</option>
            <option value="#FF0000">Red</option>
            <option value="#0000FF">Blue</option>
        </select>
        <select id="thickness">
            <option value="1">Thin</option>
            <option value="2">Medium</option>
            <option value="5">Thick</option>
        </select>
    </div>
    <script>
        const urlParams = new URLSearchParams(window.location.search);
        const imageUrl = urlParams.get('image') || 'https://via.placeholder.com/800x600'; // Fallback

        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const undoBtn = document.getElementById('undo');
        const clearBtn = document.getElementById('clear');
        const colorSelect = document.getElementById('color');
        const thicknessSelect = document.getElementById('thickness');

        let paths = []; // Array to store drawing paths for undo
        let currentPath = [];
        let drawing = false;
        let strokeColor = '#000000';
        let lineWidth = 2;

        // Function to draw the image and all paths
        function redraw() {
            // Resize canvas to full viewport
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;

            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Calculate scaling for image
            const imgAspect = img.width / img.height;
            const canvasAspect = canvas.width / canvas.height;
            let drawWidth, drawHeight, offsetX = 0, offsetY = 0;

            if (imgAspect > canvasAspect) {
                drawWidth = canvas.width;
                drawHeight = canvas.width / imgAspect;
                offsetY = (canvas.height - drawHeight) / 2;
            } else {
                drawHeight = canvas.height;
                drawWidth = canvas.height * imgAspect;
                offsetX = (canvas.width - drawWidth) / 2;
            }

            // Draw image
            ctx.drawImage(img, offsetX, offsetY, drawWidth, drawHeight);

            // Redraw all paths
            paths.forEach(path => {
                ctx.beginPath();
                ctx.moveTo(path[0].x, path[0].y);
                for (let i = 1; i < path.length; i++) {
                    ctx.lineTo(path[i].x, path[i].y);
                }
                ctx.strokeStyle = path.strokeColor;
                ctx.lineWidth = path.lineWidth;
                ctx.stroke();
            });
        }

        // Load the image
        const img = new Image();
        img.crossOrigin = 'anonymous';
        img.onload = redraw;
        img.src = imageUrl;

        // Start new path
        function startPath(e) {
            drawing = true;
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            currentPath = [{ x, y }];
            ctx.beginPath();
            ctx.moveTo(x, y);
        }

        // Draw on path
        function addToPath(e) {
            if (!drawing) return;
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            currentPath.push({ x, y });
            ctx.lineTo(x, y);
            ctx.strokeStyle = strokeColor;
            ctx.lineWidth = lineWidth;
            ctx.stroke();
        }

        // End path
        function endPath() {
            if (drawing) {
                paths.push([...currentPath, { strokeColor, lineWidth }]); // Store with styles
                currentPath = [];
                drawing = false;
            }
        }

        // Mouse events
        canvas.addEventListener('mousedown', startPath);
        canvas.addEventListener('mousemove', addToPath);
        canvas.addEventListener('mouseup', endPath);
        canvas.addEventListener('mouseout', endPath);

        // Touch events
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            startPath({ clientX: touch.clientX, clientY: touch.clientY });
        });
        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            addToPath({ clientX: touch.clientX, clientY: touch.clientY });
        });
        canvas.addEventListener('touchend', endPath);

        // Undo
        undoBtn.addEventListener('click', () => {
            if (paths.length > 0) {
                paths.pop();
                redraw();
            }
        });

        // Clear All
        clearBtn.addEventListener('click', () => {
            paths = [];
            redraw();
        });

        // Color change
        colorSelect.addEventListener('change', (e) => {
            strokeColor = e.target.value;
        });

        // Thickness change
        thicknessSelect.addEventListener('change', (e) => {
            lineWidth = parseInt(e.target.value);
        });

        // Handle resize
        window.addEventListener('resize', redraw);
    </script>
</body>
</html>
